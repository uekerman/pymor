import numpy as np
from scipy.linalg import eigh, lstsq, svd
from scipy.sparse import diags
from scipy.sparse.linalg import spsolve

from pymor.algorithms.to_matrix import to_matrix
from pymor.core.exceptions import PHDMDError
from pymor.core.logger import getLogger
from pymor.models.iosys import PHLTIModel
from pymor.operators.interface import Operator
from pymor.vectorarrays.interface import VectorArray


def phdmd(X, Y, U, Xdot=None, dt=None, H=None, initial_J=None, initial_R=None, initial_alpha=0.1, miniter=0,
          maxiter=30, atol=1e-12, rtol=1e-10, weighted_rtol=1e-12, skew_procrustes_rtol=1e-12, stagnation_window=3,
          stagnation_threshold=1e-10):
    """Solve the pH DMD problem.

    Not intended to be used directly.

    Parameters
    ----------
    X
        The |VectorArray| of the system state data.
    Y
        The |VectorArray| of the system output data.
    U
        The |VectorArray| of the system control data.
    Xdot
        If not `None`, the |VectorArray| of the system time derivative data.
        If `None`, `dt` will be used to estimate this data using the implicit midpoint rule.
    dt
        See `Xdot`.
    H
        If not `None`, the `NumPy array` representing the systems Hamiltonian.
    initial_J
        If not `None`, the `Numpy array` representing the initial guess for the `J` operator.
    initial_R
        If not `None`, the `Numpy array` representing the initial guess for the `R` operator.
    initial_alpha
        The initial value used in calculating the updated `R` operator.
    miniter
        Minimum amount of iterations to perform.
    maxiter
        Fail if the iteration count reaches this value without converging.
    atol
        Finish when the absolute update error measure is below this threshold.
    rtol
        Finish when the relative update error measure is below this threshold.
    weighted_rtol
        In the weighted pH DMD initialization problem, truncate when the relative value is
        below this threshold.
    skew_procrustes_rtol
        In the skew-symmetric Procrustes problem, truncate when the relative value is
        below this threshold.
    stagnation_window
        Finish when the relative norm of the update has been stagnating within a tolerance of
        `stagnation_threshold` during the last `stagnation_window` iterations.
    stagnation_threshold
        See `stagnation_window`.

    Returns
    -------
    J
        The `NumPy array` containing the `J` system matrix.
    R
        The `NumPy array` containing the `R` system matrix.
    data
        Dict containing the following fields:

            :update_norms:          |NumPy array| of the norms of the update vectors after
                                    each iteration.
            :abs_errs:              |NumPy array| of the absolute errors after each iteration.
            :rel_errs:              |NumPy array| of the relative  errors after each iteration.
            :iterations:            Number of total pH DMD iterations.
            :skew_procrustes_data:  `list` of data generated by the skew-symmetric
                                    Procrustes subproblems.
            :weighted_init_data:    Dict of data generated by the weighted pH DMD
                                    initialization subproblem.
    """
    assert isinstance(X, VectorArray)
    assert isinstance(Y, VectorArray)
    assert isinstance(U, VectorArray)
    assert len(X) == len(Y)
    assert len(X) % len(U) == len(Y) % len(U) == 0
    assert 0. < initial_alpha < 1.

    logger = getLogger('pymor.algorithms.phdmd.phdmd')

    if Xdot is None:
        assert dt is not None
        Xdot = (X[1:] - X[:-1]) * (1. / dt)
    else:
        assert isinstance(Xdot, VectorArray)
        assert len(X) == len(Xdot)
        assert len(X) == len(U)
        Xdot = .5 * (Xdot[1:] + Xdot[:-1])

    X = .5 * (X[1:] + X[:-1])
    Y = .5 * (Y[1:] + Y[:-1])
    U = .5 * (U[1:] + U[:-1])

    if H is None:
        logger.warn('No H matrix provided. Did you intend this?')
        H = np.eye(X.dim)
    else:
        if isinstance(H, Operator):
            assert H.source == H.range == X.space
            H = to_matrix(H)
        elif isinstance(H, VectorArray):
            assert len(H) == H.dim == X.dim
            H = H.to_numpy()

    assert isinstance(H, np.ndarray)
    assert len(H.shape) == 2

    Xdot = Xdot.to_numpy().T
    X = X.to_numpy().T
    Y = Y.to_numpy().T
    U = U.to_numpy().T

    T = np.concatenate((X, U))
    Z = np.concatenate((H @ Xdot, -Y))
    data = {}

    if initial_J is None and initial_R is not None:
        raise NotImplementedError('Cannot solve the symmetric positive semi-definite optimization problem yet!')
    elif initial_J is not None and initial_R is None:
        raise NotImplementedError('Cannot solve the skew-symmetric optimization problem yet!')
    elif initial_J is None and initial_R is None:
        logger.info('Solving weighted problem to get initial operators...')
        initial_J, initial_R, weighted_data = _weighted_phdmd(T, Z, rtol=weighted_rtol)
        data['weighted_init_data'] = weighted_data

    assert isinstance(initial_J, np.ndarray) and isinstance(initial_R, np.ndarray)
    assert len(initial_J.shape) == 2 and len(initial_R.shape) == 2
    J = initial_J
    R = initial_R

    logger.info('Running pH DMD algorithm...')

    square_matrix_data = T @ T.T
    eigvals = eigh(square_matrix_data, eigvals_only=True)
    L = max(eigvals)
    mu = min(eigvals)
    ev_ratio = mu / L

    alphas = [initial_alpha]
    betas = []
    abs_errs = [np.linalg.norm(Z - (J - R) @ T, 'fro')]
    rel_errs = [abs_errs[0] / np.linalg.norm(Z, 'fro')]
    update_norms = []
    procrustes_data = []

    Q = R
    iteration = 0
    update_norm = np.inf
    while True:
        logger.info(f'Starting pH DMD algorithm iteration {iteration} with '
                    f'current errors abs: {abs_errs[-1]} rel: {rel_errs[-1]}...')

        if iteration >= miniter:
            if abs_errs[-1] < atol:
                logger.info(f'pH DMD converged in {iteration} iterations because '
                            f'absolute error tolerance of {atol} was reached.')
                break
            if rel_errs[-1] < rtol:
                logger.info(f'pH DMD converged in {iteration} iterations because '
                            f'relative error tolerance of {rtol} was reached.')
                break
            if update_norm < rtol:
                logger.info(f'pH DMD converged in {iteration} iterations because '
                            f'relative update tolerance of {rtol} was reached.')
                break
            if iteration >= maxiter:
                logger.info(f'Maximum iterations reached. Failed to converge after {iteration} iterations.')
                raise PHDMDError('Failed to converge after the maximum amount of iterations.')

        iteration += 1

        R_prev = R
        J_prev = J

        Z_1 = Z + R @ T
        logger.info('Solving skew-symmetric Procrustes subproblem...')
        J, skew_procrustes_data = _skew_symmetric_procrustes(T, Z_1, rtol=skew_procrustes_rtol)
        procrustes_data.append(skew_procrustes_data)
        Z_2 = J @ T - Z
        G = Q @ square_matrix_data - Z_2 @ T.T

        R = _project_spsd(Q - (1. / L) * G)
        last_alpha = alphas[-1]
        alpha = (np.sqrt((last_alpha ** 2 - ev_ratio) ** 2 + 4 * last_alpha ** 2) + (ev_ratio - last_alpha ** 2)) / 2.
        beta = last_alpha * (1 - last_alpha) / (last_alpha ** 2 + alpha)
        Q = R + beta * (R - R_prev)

        alphas.append(alpha)
        betas.append(beta)

        abs_errs.append(np.linalg.norm(Z - (J - R) @ T, 'fro'))
        rel_errs.append(abs_errs[-1] / np.linalg.norm(Z, 'fro'))
        update_norm = np.linalg.norm(J_prev - J, 'fro') / np.linalg.norm(J, 'fro') \
                    + np.linalg.norm(R_prev - R, 'fro') / np.linalg.norm(J, 'fro')
        update_norms.append(update_norm)

    data['update_norms'] = np.array(update_norms)
    data['abs_errs'] = np.array(abs_errs)
    data['rel_errs'] = np.array(rel_errs)
    data['iterations'] = iteration
    data['skew_procrustes_data'] = procrustes_data

    data_dim = len(X)
    inf_J = J[:data_dim, :data_dim]
    inf_G = J[:data_dim, data_dim:]
    inf_N = J[data_dim:, data_dim:]
    inf_R = R[:data_dim, :data_dim]
    inf_P = R[:data_dim, data_dim:]
    inf_S = R[data_dim:, data_dim:]
    inf_model = PHLTIModel.from_matrices(
        inf_J, inf_R, inf_G, inf_P, inf_S, inf_N, H
    )

    return inf_model, data


def _weighted_phdmd(X, Y, rtol=1e-12):
    """Solve the weighted pH DMD problem.

    Not intended to be used directly.

    Parameters
    ----------
    X
        The `NumPy array` containing the input data to be fit.
    Y
        The `NumPy array` containing the output data to be fit.
    rtol
        Truncate when the relative value is below this threshold.

    Returns
    -------
    J
        The `NumPy array` containing the `J` system matrix.
    R
        The `NumPy array` containing the `R` system matrix.
    data
        Dict containing the following fields:

            :abs:   Value of absolute solution error.
            :rel:   Value of relative solution error.
    """
    assert isinstance(X, np.ndarray) and isinstance(Y, np.ndarray)
    assert len(X.shape) == 2 and len(Y.shape) == 2
    assert X.shape[1] == Y.shape[1]

    logger = getLogger('pymor.algorithms.phdmd.weighted_phdmd')

    data_dim = len(X)

    U, s_vals, V = svd(X)

    rank = np.argmax(s_vals / s_vals[0] < rtol)
    rank = rank if rank > 0 else len(s_vals)

    trunc_S = diags(s_vals[:rank])
    trunc_S_inv = diags(1. / s_vals[:rank])

    if rank < data_dim:
        logger.warn(f'Deficient rank ({rank} < {data_dim})!')

    Z_1 = U.T @ Y @ V.T

    helper = trunc_S @ Z_1[:rank, :rank]
    J_11 = .5 * (helper - helper.T)
    R_11 = _project_spsd(-helper)
    J = U[:, :rank] @ trunc_S_inv @ J_11 @ trunc_S_inv @ U[:, :rank].T
    R = U[:, :rank] @ trunc_S_inv @ R_11 @ trunc_S_inv @ U[:, :rank].T

    if rank < data_dim:
        J_21, _, _, _ = lstsq(trunc_S.todense(), Z_1[rank:, :rank].T, cond=None)
        top_filler = np.zeros((data_dim - rank, data_dim - rank))
        top_comp = np.hstack((top_filler, J_21.T))
        bottom_filler = np.zeros((rank, rank))
        bottom_comp = np.hstack((-J_21, bottom_filler))
        compensation = np.vstack([top_comp, bottom_comp])

        J = J + U @ compensation @ U.T

    abs_err = np.linalg.norm(X.T @ Y - X.T @ (J - R) @ X, 'fro')
    rel_err = abs_err / np.linalg.norm(X.T @ Y, 'fro')
    data = {'abs': abs_err, 'rel': rel_err}

    return J, R, data


def _project_spsd(matrix):
    """Project the matrix onto the set of symmetric and positive semidefinite matrices.

    Parameters
    ----------
    matrix
        The `NumPy array` containing the data to project.
    """
    assert isinstance(matrix, np.ndarray)
    assert len(matrix.shape) == 2

    matrix = .5 * (matrix + matrix.T)
    eig_vals, eig_vecs = eigh(matrix)
    return eig_vecs @ diags(eig_vals.clip(min = 0)) @ eig_vecs.T


def _skew_symmetric_procrustes(X, Y, rtol=1e-12):
    """Solve the skew-symmetric Procrustes problem.

    Not intended to be used directly.

    Parameters
    ----------
    X
        The `NumPy array` containing the input data to be fit.
    Y
        The `NumPy array` containing the output data to be fit.
    rtol
        Truncate when the relative value is below this threshold.

    Returns
    -------
    A
        The `NumPy array` containing the matrix mapping `X` to `Y`.
    data
        Dict containing the following fields:

            :abs:   Value of absolute fitting error.
            :rel:   Value of relative fitting error.
    """
    assert isinstance(X, np.ndarray) and isinstance(Y, np.ndarray)
    assert len(X.shape) == 2 and len(Y.shape) == 2
    assert X.shape[1] == Y.shape[1]

    data_dim = len(X)

    U, s_vals, V = np.linalg.svd(X)
    V = V.conj().T

    rank = np.argmax(s_vals / s_vals[0] < rtol)
    rank = rank if rank > 0 else len(s_vals)

    trunc_s_vals = s_vals[:rank]
    trunc_S = diags(trunc_s_vals)

    Y_trans = U.T @ Y @ V
    Z_1 = Y_trans[:rank, :rank]
    Z_3 = Y_trans[rank:, :rank].T

    [ii, jj] = np.mgrid[:rank, :rank]
    phi = 1. / (np.square(trunc_s_vals[ii]) + np.square(trunc_s_vals[jj]))

    A_1 = phi * (Z_1 @ trunc_S - trunc_S @ Z_1.T)
    A_2 = -spsolve(trunc_S.tocsc(), Z_3)
    A_4 = np.zeros((data_dim - rank, data_dim - rank))
    A_1 = np.hstack((A_1, A_2))
    A_4 = np.hstack((-A_2.T, A_4))
    A = np.concatenate((A_1, A_4))
    A = U @ A @ U.T

    A_abs = np.abs(A)
    indices = np.where(A_abs / np.amax(A_abs) < rtol)
    A[indices] = 0.

    abs_err = np.linalg.norm(A @ X - Y, 'fro')
    rel_err = abs_err / np.linalg.norm(Y, 'fro')
    data = {'abs': abs_err, 'rel': rel_err}

    return A, data
